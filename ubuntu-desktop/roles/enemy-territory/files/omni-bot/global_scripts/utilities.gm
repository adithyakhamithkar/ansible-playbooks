// This script contains useful utility scripts for performing common actions.

member PlayerClassTable = {};

// This is used as an alternative to grounding goals created by waypoint flags. Each game using waypoints
// should define this in <game>_utilities.gm
member WaypointGoalOffset = Vector3(0,0,0);

// color string for debug messages
member DebugColorString = "";

// games can define goal types that will have route tables auto initialized with makemapgm
member PrimaryRouteGoalQuery = "";

//////////////////////////////////////////////////////////////////////////
// Helper function for getting a bot by name.
member GetBotByName = function(name)
{
	foreach(i and bot in BotTable)
	{
		if(bot.Name == name)
		{
			return bot;
		}
	}
	return null;
};

member IsHuman = function(ent)
{
	return ent != null && GetEntFlags(ent, ENTFLAG.HUMANCONTROLLED);
};

member IsBot = function(ent)
{
	if (ent)
	{
		b = Util.GetBotByName(GetEntName(ent));
		if (b) { return b; }
	}

	return null;
};

member EntityPositionByName = function(entname)
{
	e = GetEntityByName(entname);
	assert(e, "Entity: " + entname + " not found!");
	return GetEntPosition(e);
};

///////////////////////////////////////////////////////////////////////////////

member MakeRGBA = function(r, g, b, a)
{
	assert( typeName(r) == "int", "Param1 wrong type" );
	assert( typeName(g) == "int", "Param2 wrong type" );
	assert( typeName(b) == "int", "Param3 wrong type" );

// alpha is optional
	alpha = 255;
	if(a)
	{
		assert( typeName(a) == "int" );
		alpha = a;
	}

	return (((alpha)<<24) | ((b)<<16) | ((g)<<8) | (r));
};

member Mash = function(a,b)
{
	assert( typeName(a) == "int", "Param1 wrong type" );
	assert( typeName(b) == "int", "Param2 wrong type" );
	return (((a)<<16) | (b));
};

///////////////////////////////////////////////////////////////////////////////

member WaypointAutoSaveInfo =
{
	SaveThreadId = null,
};

///////////////////////////////////////////////////////////////////////////////

member WaypointAutoSaveFunction = function(_delay)
{
	print("Util.WaypointAutoSaveFunction: Will auto-save waypoints every", _delay, "seconds.");

	// Loop as long as waypoint mode is on.
	while( Wp.IsWaypointViewOn() )
	{
		ExecCommand( "waypoint_save" );
		sleep( _delay );
	}

	print("Util.WaypointAutoSaveFunction: Waypoint auto saving disabled with waypoint_view 0");
};

///////////////////////////////////////////////////////////////////////////////

member EnableWaypointAutoSave = function( _enable, _time )
{
	if( _enable )
	{
		if( _time < 5 ) { _time = 5; }

		print("Util.EnableWaypointAutoSave: Enabling waypoint autosave");
		ExecCommand("waypoint_view 1");

		if( this.WaypointAutoSaveInfo.SaveThreadId != null )
		{
			threadKill( this.WaypointAutoSaveInfo.SaveThreadId );
		}
		this.WaypointAutoSaveInfo.SaveThreadId = thread( this.WaypointAutoSaveFunction, _time );
	}
	else
	{
		// Kill the thread if it exists, and null the
		if( this.WaypointAutoSaveInfo.SaveThreadId != null )
		{
			threadKill( this.WaypointAutoSaveInfo.SaveThreadId );
			print("Util.EnableWaypointAutoSave: Disabled waypoint autosave");
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetMapGoalPosition = function( _params )
{
	Goalname = _params;
	Goal = GetGoal( Goalname );

	if ( Goal )
	{
		GoalPos = Goal.GetPosition();

		if ( GoalPos == Vector3( 0.0, 0.0, 0.0 ) )
		{
			GoalEnt = Goal.GetEntity();
			EntPos = GetEntPosition( GoalEnt );

			if ( EntPos != GoalPos )
			{
				GoalPos = EntPos;
			}
		}

		return GoalPos;
	}
	else
	{
		print("Util.GetMapGoalPosition: No such goal", Goalname);
		return null;
	}
};

///////////////////////////////////////////////////////////////////////////////
// todo: deprecate
member WithinRange = function( bot, range )
{
	playerPos = GetLocalPosition();

	while ( bot.DistanceTo( playerPos ) > range )
	{
		playerPos = GetLocalPosition();
		yield();
	}
	return;
};

///////////////////////////////////////////////////////////////////////////////
// deprecate
member AddBotKickWhenDead = function( team, class, name )
{
	AddBot( team, class, name );
	sleep( 1 );

	bot = this.GetBotPointer( name );
	bot.AddSignalThread(threadId(), false);
	block( EVENT.DEATH );
	KickBot( name );
};

///////////////////////////////////////////////////////////////////////////////
//
member IsBotGone = function( name )
{
	foreach ( id and bot in BotTable )
	{
		if ( bot.Name == name )
			{ return false; }
	}

	return true;
};

///////////////////////////////////////////////////////////////////////////////
//
member WaitUntilBotGone = function( name )
{
	bot_gone = false;

	while( !bot_gone )
	{
		if ( this.Skip )
			{ return; }

		foreach ( id and bot in BotTable )
		{
			if ( bot.Name == name )
			{
				bot_gone = false;
				break;
			}

			bot_gone = true;
		}

		yield();
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member WaitUntilBotSpawned = function( name )
{
	bot_spawned = false;

	while( !bot_spawned )
	{
		foreach ( id and bot in BotTable )
		{
			if ( bot.Name == name )
			{
				bot_spawned = true;
				break;
			}

			bot_spawned = false;
		}

		yield();
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member WaitForPlayerSpawn = function()
{
	sleep( 1 );

// Wait for player
	playerPos = GetLocalPosition();

	while ( !playerPos || playerPos == Vector3( 0.0, 0.0, 0.0 ) )
	{
		sleep( 1 );
		playerPos = GetLocalPosition();
	}

	return playerPos;
};

///////////////////////////////////////////////////////////////////////////////
//
member GetWpGUIDPosition = function( _params )
{
	WpGUID = _params;
	wptable = table();
	Wp = Wp.GetWaypointByGUID( WpGUID, wptable );

	if ( Wp )
	{
		return wptable.position;
	}
	else
	{
		print("Util.GetWpGUIDPosition: No such waypoint");
		return null;
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member WpNameInfo = function( wpName )
{
	wpTable = table();
	Wp = Wp.GetWaypointByName(wpName, wpTable);

	if ( Wp )
	{
		return wpTable;
	}
	else
	{
		return null;
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetWpNamePosition = function( _params )
{
	WpName = _params;
	wptable = table();
	Wp = Wp.GetWaypointByName( WpName, wptable );

	if ( Wp )
	{
		return wptable.position;
	}
	else
	{
		print("Util.GetWpNamePosition: No such waypoint", WpName);
		return null;
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetWPPoss = function( wps )
{
	wpPoss = table();

	foreach ( index and wp in wps )
		{ wpPoss[ index ] = this.GetWpNamePosition( wp ); }

	return wpPoss;
};

///////////////////////////////////////////////////////////////////////////////
//
member Distance = function( Pos1, Pos2 )
{
	return ( Pos2 - Pos1 ).Length();
};

///////////////////////////////////////////////////////////////////////////////
//
member GetClosestWP = function( entPos, wp1, wp2 )
{
	wp1Pos = this.GetWpNamePosition( wp1 );
	dist1 = this.Distance( entPos, wp1Pos );
	wp2Pos = this.GetWpNamePosition( wp2 );
	dist2 = this.Distance( entPos, wp2Pos );

	if ( dist1 < dist2 )
		{ return wp1; }
	else
		{ return wp2; }
};

///////////////////////////////////////////////////////////////////////////////
//
member GetClosestRoute = function( entPos, route1, route2 )
{
	route1Pos = this.GetWpNamePosition( route1[ 0 ] );
	dist1 = this.Distance( entPos, route1Pos );
	route2Pos = this.GetWpNamePosition( route2[ 0 ] );
	dist2 = this.Distance( entPos, route2Pos );

	if ( dist1 < dist2 )
		{ return route1; }
	else
		{ return route2; }
};

///////////////////////////////////////////////////////////////////////////////
//
member GetClosestRouteToPlayer = function( route1, route2 )
{
	playerPos = GetLocalPosition();
	route = this.GetClosestRoute( playerPos, route1, route2 );
	return route;
};

///////////////////////////////////////////////////////////////////////////////
//
member BotWaitAndSay = function( bot, time, dialog )
{
	if ( time )
		{ sleep( time ); }

	bot.Say( dialog );
};

///////////////////////////////////////////////////////////////////////////////
//
member BotSayAndWait = function( bot, dialog, time )
{
	bot.Say( dialog );

	if ( time )
		{ sleep( time ); }
};

///////////////////////////////////////////////////////////////////////////////
//
member WithinBounds = function( entPos, minx, miny, maxx, maxy )
{
	if ( entPos.x < minx || entPos.x > maxx ||
		entPos.y < miny || entPos.y > maxy )
	{
		return false;
	}

	return true;
};

///////////////////////////////////////////////////////////////////////////////
//
member DialogOff = false;

///////////////////////////////////////////////////////////////////////////////
//
member Dialog = function( bot, paragraph, time )
{
	if ( this.DialogOff )
		{ return; }

	foreach ( index and sentence in paragraph )
	{
		if ( this.Skip )
			{ return; }

		this.BotSayAndWait( bot, sentence, time );
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member FollowWaypoints = function( bot, waypoints, range )
{
	if ( this.Skip )
		{ return; }

	this.WithinRange( bot, range );

	if ( this.Skip )
		{ return; }

	wpPoss = this.GetWPPoss( waypoints );
	start = 0;
	end = tableCount( waypoints );
	botPos = bot.GetPosition();

	for ( i = 0 ; i < end - 1 ; i = i + 1 )
	{
		dist1 = this.Distance( botPos, wpPoss[ start ] );
		dist2 = this.Distance( botPos, wpPoss[ i + 1 ] );

		if ( dist2 < dist1 )
			{ start = i + 1; }
	}

//~ foreach ( index and waypoint in waypoints )
	for ( i = start ; i < end ; i = i + 1 )
	{
		mapPos =wpPoss[ i ];
		botFacing = GetEntFacing( 2 );
		bot.GoTo( mapPos, botFacing );

		if ( block(EVENT.GOAL_SUCCESS, EVENT.GOAL_FAILED) ==
			EVENT.GOAL_FAILED )
		{
			print("Util.FollowWaypoints:", GetMapName(), "_training: follow route: ", waypoints[ i ], " failed" );
			return 0;
		}

		if ( this.Skip )
			{ return; }

		this.WithinRange( bot, range );

		if ( this.Skip )
			{ return; }
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetBotPointer = function( name )
{
	foreach ( id and bot in BotTable )
	{
		if ( bot.Name == name )
			{ return bot; }
	}

	return null;
};

///////////////////////////////////////////////////////////////////////////////
//
member BotDebug = false;

member EnableBotDebug = function( status )
{
	print( "Util.EnableBotDebug: Enabling debug console" );
	this.BotDebug = status;
};

///////////////////////////////////////////////////////////////////////////////
//
member Skip = false;

member SetSkip = function()
{
	this.Skip = true;
};

///////////////////////////////////////////////////////////////////////////////
//
member ResetSkip = function()
{
	this.Skip = false;
};

///////////////////////////////////////////////////////////////////////////////
//
member SetPropertyTeamClassGoal = function( property, team, class, goal, value )
{
	foreach ( gameId and bot in BotTable )
		{ if ( bot )
			{ if ( bot.GetTeam() == team )
				{ if ( bot.GetClass() == class )
					{ bot.SetGoalProperty( goal, property, value ); } } } }
};

///////////////////////////////////////////////////////////////////////////////
//
member SetGoalOffset = function( x, y, z, GoalName )
{
	Goal = GetGoal( GoalName );
	if(Goal)
	{
		Goal.SetPosition( Goal.GetPosition() + Vector3( x, y, z ) );
		Goal.DynamicPosition = false;
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetGoalPosition = function( x, y, z, GoalName )
{
	Goal = GetGoal( GoalName );
	if(Goal)
	{
		Goal.SetPosition( Vector3( x, y, z ) );
		Goal.DynamicPosition = false;
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetGoalBounds = function( bounds, GoalName )
{
	Goal = GetGoal( GoalName );
	if(Goal)
	{
		Goal.SetBounds( bounds );
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetMaxUsers = function( Users, GoalNames )
{
	Goals = Util.GoalTable(GoalNames);

	foreach ( index and Goal in Goals )
	{
		Goal.MaxUsers_InUse( Users );
		Goal.MaxUsers_InProgress( Users );
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetMaxUsers = function( GoalNames )
{
	Goals = table();
	GetGoals( Goals, 0, GoalNames );

	foreach ( index and Goal in Goals ) {
		numInUse = Goal.MaxUsers_InUse();
		numInProgress = Goal.MaxUsers_InProgress();
		print(format("%s: %d users in use; %d users in progress", Goal.GetName(), numInUse, numInProgress));
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetMaxUsersInUse = function( Users, GoalNames )
{
	Goals = table();
	GetGoals( Goals, 0, GoalNames );

	foreach ( index and Goal in Goals )
		{ Goal.MaxUsers_InUse( Users ); }
};

///////////////////////////////////////////////////////////////////////////////
//
member GetMaxUsersInUse = function( GoalNames )
{
	Goals = table();
	GetGoals( Goals, 0, GoalNames );

	foreach ( index and Goal in Goals ) {
		num = Goal.MaxUsers_InUse();
		print(format("%s: %d users in use", Goal.GetName(), num));
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetMaxUsersInProgress = function( Users, GoalNames )
{
	Goals = table();
	GetGoals( Goals, 0, GoalNames );

	foreach ( index and Goal in Goals )
		{ Goal.MaxUsers_InProgress( Users ); }
};

///////////////////////////////////////////////////////////////////////////////
//
member GetMaxUsersInProgress = function( GoalNames )
{
	Goals = table();
	GetGoals( Goals, 0, GoalNames );

	foreach ( index and Goal in Goals ) {
		num = Goal.MaxUsers_InProgress();
		print(format("%s: %d users in progress", Goal.GetName(), num));
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetPercentInProgress = function ( percent, GoalNames )
{
	yield();yield(); // OnMapLoad needs two frames for BotTable to populate

	numbots = tableCount(BotTable)  * 0.5;
	factor = percent * .01;

	x = numbots * factor;
	inprogress = ToInt(Round(x));

	if ( inprogress > 0 )
		{ this.SetMaxUsersInProgress( inprogress, GoalNames ); }
	else
		{ this.SetMaxUsersInProgress( 1, GoalNames ); }
};

///////////////////////////////////////////////////////////////////////////////
//
member AddToTable = function( table1, value1 )
{
	table1[ tableCount( table1 ) ] = value1;
};

///////////////////////////////////////////////////////////////////////////////
//
member AddTable = function( table1, table2 )
{
	table1and2 = table();

	table1len = tableCount( table1 );

	for ( i = 0 ; i < table1len ; i = i + 1 )
		{ table1and2[ i ] = table1[ i ]; }

	table2len = tableCount( table2 );

	for ( i = 0 ; i < table2len ; i = i + 1 )
		{ table1and2[ i + table1len ] = table2[ i ]; }

	return table1and2;
};

///////////////////////////////////////////////////////////////////////////////
//
// This function runs an infinite loop of adding and kicking bots. It is used to illustrate
// how custom script functions can be run continuously to provide custom control over
// things like the number of bots. Additional behaviors like forcing bots to 1 team can be
// implemented by starting a similar function to this from a custom command.
member StressTest = function()
{
	sleep(10.0);
	dowhile(1)
	{
	//DumpGlobals("globals.txt");

		ran = UnitRandom();
		if(ran > 0.98)
		{
		//KickAll();
		}
		else if(ran < 0.5)
		{
			AddBot();
		}
		else
		{
			foreach ( gameId and bot in BotTable )
			{
				if(bot)
				{
					print("Util.StressTest:", bot);
					KickBot(bot.Name);
					break;
				}
			}
		}
		  // Pause for 10 seconds between loop iterations.
		  sleep(RandRange(0.0, 3.0));
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetNearestVehicle = function( bot, dist )
{
	if ( bot == null )
		{ return null; }

	this.VehiclesInMap();

	Team = bot.GetTeam();

	if ( !dist )
		{ dist = 10000.0; }

	foreach ( vehEntity and Goal in this.VehicleGoals )
	{
		if ( Goal.IsAvailable( Team ) &&
			bot.DistanceTo( vehEntity ) < dist )
			{ return vehEntity; }
	}

	return null;
};

///////////////////////////////////////////////////////////////////////////////
//
member GetNearestMountableVehicle = function( bot, dist )
{
	if ( bot == null ) {
		return null;
	}

	// cache these. the assumption is that mountable vehicles won't be deleted
	if ( !this.MountableVehicleGoals  ) {
		this.VehiclesInMap();
	}

	Team = bot.GetTeam();

	if ( !dist ) {
		dist = 10000.0;
	}

	foreach ( vehEntity and Goal in this.MountableVehicleGoals ) {
		if ( !GetEntFlags(vehEntity, ENTFLAG.MOUNTABLE) ) {
			continue;
		}

		if ( Goal.IsAvailable( Team ) && bot.DistanceTo( vehEntity ) < dist ) {
			return vehEntity;
		}
	}

	return null;
};

///////////////////////////////////////////////////////////////////////////////
//
member GetVehicleGoalName = function( entity )
{
	if ( bot == entity )
		{ return entity; }

	this.VehiclesInMap();

	foreach ( vehEntity and Goal in this.VehicleGoals )
	{
//~ print("vehEntity:", vehEntity, "entity:", entity, "Goal:", Goal, "Name:", Goal.GetName());
		if ( vehEntity == entity )
			{ return Goal.GetName(); }
	}

	return null;
};

///////////////////////////////////////////////////////////////////////////////
//
member IsVehicleAvailable = function( bot, entity )
{
	if ( bot == null )
		{ return null; }

	this.VehiclesInMap();

	if ( this.VehicleGoals[ entity ] )
	{
		Team = bot.GetTeam();

		if ( this.VehicleGoals[ entity ].IsAvailable( Team ) )
			{ return true; }
	}

	return false;
};

///////////////////////////////////////////////////////////////////////////////
//
member IsVehicleDead = function( entity )
{
	if ( GetEntClass(entity) == CLASS.VEHICLE_NODAMAGE )
		{ return false; }

	if ( Map && Map.InvVehicle && Map.InvVehicle[ entity ] )
		{ return false; }

	if ( GetEntFlags(entity, ENTFLAG.DEAD) )
		{ return true; }

	return false;
};

///////////////////////////////////////////////////////////////////////////////
//
member VehiclesInMap = function()
{
	if ( this.VehicleGoals == null )
	{
		this.VehicleGoals = table();
		this.MountableVehicleGoals = table();
		this.MoverGoals = table();
	}

	// cs: this needs constantly updated to handle movers that are deleted
	tableClear(this.VehicleGoals);
	tableClear(this.MoverGoals);
	tableClear(this.MountableVehicleGoals);
	this.MoverGoals = Util.GoalTable("MOVER_.*");

	haveGoals = false;
	foreach ( id and Goal in this.MoverGoals )
	{
		if (!haveGoals )
		{
			haveGoals = true;
		}
		vehEntity = Goal.GetEntity();
		this.VehicleGoals[ vehEntity ] = Goal;

		// dead movers too i guess
		if ( GetEntFlags( vehEntity, ENTFLAG.MOUNTABLE ) || GetEntFlags( vehEntity, ENTFLAG.DEAD )  )
		{
			this.MountableVehicleGoals[ vehEntity ] = Goal;
		}

	}

	return haveGoals;
};

///////////////////////////////////////////////////////////////////////////////
//
member DisplayGoalThread = null;
member NumberOfGoals = 0;
member GoalNames = table();
member GoalStatuses = table();

///////////////////////////////////////////////////////////////////////////////
//
member DisplayGoalOutput = function()
{
	while ( true )
	{
		for ( i = 0 ; i < Util.NumberOfGoals ; i = i + 1 )
		{
			if ( Util.GoalStatuses[ i ] )
			{
				GoalName = Util.GoalNames[ i ];
				GoalPos = Util.GetMapGoalPosition( GoalName );
				Goal = GetGoal( GoalName );
				GoalEnt = Goal.GetEntity();
				GoalFacing = GetEntFacing( GoalEnt );
				print( "Util.DisplayGoalOutput:", GoalName, GoalPos, GoalFacing );
			}
		}

		sleep( Util.NumberOfGoals );
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member DisplayGoal = function( goalname, status )
{
	if ( !this.DisplayGoalThread )
	{
		this.DisplayGoalThread = thread( this.DisplayGoalOutput );
	}
	else
	{
		if ( !goalname )
		{
			threadKill( this.DisplayGoalThread );
			this.DisplayGoalThread = null;
			this.NumberOfGoals = 0;
			return;
		}
	}

	if ( !status || status == "false" )
	{
		for ( i = 0 ; i < this.NumberOfGoals ; i = i + 1 )
		{
			if ( this.GoalNames[ i ] == goalname )
				{ this.GoalStatuses[ i ] = false; }
		}

		return;
	}
	else
	{
		haveit = false;

		for ( i = 0 ; i < this.NumberOfGoals ; i = i + 1 )
		{
			if ( this.GoalNames[ i ] == goalname )
			{
				this.GoalStatuses[ i ] = true;
				haveit = true;
			}
		}

		if ( haveit )
			{ return; }

		if ( this.GetMapGoalPosition( goalname ) )
		{
			this.GoalNames[ this.NumberOfGoals ] = goalname;
			this.GoalStatuses[ this.NumberOfGoals ] = true;
			this.NumberOfGoals = this.NumberOfGoals + 1;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member KillTeam = function( team )
{
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team)
		{
			bot.ExecCommand( "kill" );
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member OnTriggerPosition = function( goalname, wpname, tolerance, wpfunction )
{
	if ( typeId( goalname ) == 5 )
		{ goal = GetGoal( goalname ); }
	else
		{ goal = goalname; }

	position = this.GetWpNamePosition( wpname );

	if ( goal && position )
	{
		if ( typeId( goalname ) == 5 )
			{ entity = goal.GetEntity(); }
		else
			{ entity = goal; }

		thread( this.CheckForEntityAtPosition, wpname, entity, position,
			tolerance, wpfunction );
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member CheckForEntityAtPosition = function( signame, entity, position, tolerance, wpfunction )
{
	while ( 1 )
	{
		entposition = GetEntPosition( entity );
		distance = DistanceBetween( entposition, position );
	//~ print("distance:", distance, "tolerance:", tolerance);

		if ( distance < tolerance )
		{
			signal( signame );

			if ( wpfunction )
				{ wpfunction(); }

			return;
		}

		sleep(1);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member UpdateSwitchData = function()
{
	foreach ( name and switchTable in Map.Switches )
	{
		switchTable.Waypoint = table();

		if ( Wp.GetWaypointByName( switchTable.WaypointName,
			switchTable.Waypoint ) )
		{
			Util.MapDebugPrint( "Util.UpdateSwitchData: Switch Data Suceeded, Waypoint:" +
				switchTable.WaypointName, true );

			if ( switchTable.Waypoint.facing.IsZero() )
				{ Util.MapDebugPrint( "Util.UpdateSwitchData: Error: No Facing Defined, Waypoint:" +
					switchTable.WaypointName, true ); }
		}
		else
		{
			Util.MapDebugPrint( "Util.UpdateSwitchData: Error: Switch Data Failed, Waypoint:",  switchTable.WaypointName, true );
		}

		switchTable.Serial = AllocGoalSerialNum();
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member BotsWithGoal = function( params )
{
	numbots = 0;

	foreach ( id and bot in BotTable )
	{
		if ( bot.scriptgoal == params )
			{ numbots = numbots + 1; }
	}

	return numbots;
};

///////////////////////////////////////////////////////////////////////////////
//
member SetPositionGoal = function( goalname1, goalname2, offset )
{
	if (!offset) { offset = Vector3(0,0,0); }

	goal1 = GetGoal( goalname1 );
	goal2 = GetGoal( goalname2 );

	if ( !goal1 || !goal2 )
	{
		print( "Util.SetPositionGoal: Null goal(s)", goal1, goal2 );
		return;
	}

	goal1.DynamicPosition = false;
	goal1.DynamicBounds = false;
	goal1.SetPosition( goal2.GetPosition() + offset );

	return;
};

///////////////////////////////////////////////////////////////////////////////
//
member AliveCount = function ( team, class )
{
	count = 0;

	for ( i = 0; i < Server.MaxPlayers; i = i + 1 )
	{
		if (!EntityIsValid(i) ) {
			continue;
		}

		if ( GetEntTeam(i) == team && GetEntClass(i) == class && !GetEntFlags(i, ENTFLAG.DEAD, ENTFLAG.LIMBO) ) {
			count += 1;
		}
	}

	return count;
};

///////////////////////////////////////////////////////////////////////////////
//
member ShowEntityInfo = function (traceType)
{
	if ( typeId(traceType) == 0 )
	{
		traceType = TRACE.SHOT;
	}

	info = table();
	playerEnt = GetLocalEntity();
	playerId = GetGameIdFromEntity(playerEnt);
	info.eyePos = GetLocalEyePosition();
	info.endPos = info.eyePos + GetLocalFacing() * 1024;
	tr = TraceLine( info.eyePos, info.endPos, 0, traceType, playerId, false );
	if(tr.end){ DrawDebugLine( info.eyePos, tr.end, COLOR.GREEN, 20 ); }

	if ( !tr.entity || !EntityIsValid(tr.entity) )
	{
		displaytime = 3;
		output = "No entity found";
	}
	else
	{
		DrawEntityOBB( tr.entity, 20, COLOR.GREEN );
		info.id = GetGameIdFromEntity( tr.entity );
		info.class = Util.ClassName(GetEntClass(tr.entity));
		s = format( "%s(%d) class:%s", GetEntityName(tr.entity), info.id, info.class );
		displaytime = 20;
		output = "Entity found:" + s;
	}

	print( "Util.ShowEntityInfo:", output );
	EchoToScreen( displaytime, output );

	return info;
};

///////////////////////////////////////////////////////////////////////////////
//
member TraceForEntityInfo = function (startPos, endPos, traceType)
{
	if ( typeId(traceType) == 0 )
	{
		traceType = TRACE.SHOT;
	}

	id = null;
	tr = TraceLine( startPos, endPos, 0, traceType, 0, false );

	if (tr.entity)
	{
		id = GetGameIdFromEntity(tr.entity);
	}

	return id;
};

///////////////////////////////////////////////////////////////////////////////
//
member TraceForPosition = function()
{
	tr = Util.TraceFromPlayer();
	if ( tr.end ) {
		return tr.end;
	}
	else {
		print("Util.TraceForPosition: unable to find position" );
		return Vector3(0,0,0);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member TraceFromPlayer = function(distance, traceType)
{
	if( !distance ) { distance = 50000; }
	if( !traceType) { traceType=TRACE.SHOT; }

	eyePos = GetLocalEyePosition();
	tr = TraceLine( eyePos, eyePos + GetLocalFacing() * distance, 0, traceType, GetGameIdFromEntity(GetLocalEntity()), false );
	if ( tr.end && (MAP_DEBUG || (Map && Map.Debug)) ) { DrawDebugLine( eyePos, tr.end, COLOR.GREEN, 5 ); }
	return tr;
};

///////////////////////////////////////////////////////////////////////////////
//
member TraceFromPlane = function(start, normal, distance)
{
	tr = TraceLine( start, start + normal * distance, 0, TRACE.SHOT, GetGameIdFromEntity(GetLocalEntity()), false );
	if ( MAP_DEBUG || (Map && Map.Debug) ) { DrawDebugLine( start, start + normal * distance, COLOR.BLUE, 5 ); }
	return tr;
};

///////////////////////////////////////////////////////////////////////////////
//
member AddUsePtFromWp = function(GoalName, wpname)
{
	this.AddUseWp(GoalName, wpname);
};

///////////////////////////////////////////////////////////////////////////////
//
member AddUsePoint = function( goalname, positions )
{
	mg = GetGoal(goalname);
	if ( mg )
	{
		if ( typeId(positions) == 6 )
		{
			foreach( id and pos in positions ) {
				mg.AddUsePoint(pos);
			}
		}
		else {
			mg.AddUsePoint(positions);
		}
	}
	else
		{ print("Util.SetUsePoint: ", goalname, " is invalid"); }
};

///////////////////////////////////////////////////////////////////////////////
//
member AddUseWp = function( goalname, wpName )
{
	if ( typeId(wpName) == 6 )
	{
		this.AddUsePoint(goalname, this.GetWPPoss(wpName));
	}
	else
	{
		this.AddUsePoint(goalname, this.GetWpNamePosition(wpName));
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member AddGoalRoute = function(goalname, startname, endname, weight)
{
	if(weight==null)
	{
		weight = 1.0;
	}

	s = GetGoal(startname);
	e = GetGoal(endname);

	if (typeName(goalname) == "table")
	{
		if ( s && e )
		{
			foreach (goal in goalname)
			{
				goal.AddRoute(startname, endname, weight);
			}
			return true;
		}
	}
	else
	{
		g = GetGoal(goalname);
		if ( !g )
		{
			Util.MapDebugPrint("Util.AddGoalRoute: Goal " + goalname + " not found!", true);
		}
		else if ( s && e )
		{
			return g.AddRoute(startname, endname, weight);
		}
	}
	if( !s )
	{
		Util.MapDebugPrint("Util.AddGoalRoute: Goal " + startname + " not found! " +
				startname + " -> " + endname, true);
	}
	if ( !e )
	{
		Util.MapDebugPrint("Util.AddGoalRoute: Goal " + endname + " not found! " +
				startname + " -> " + endname, true);
	}
	return false;
};

///////////////////////////////////////////////////////////////////////////////
//
member RouteTo = function(goalname, routepath)
{
	nodes = routepath.Tokenize(".");

	numNodes = tableCount(nodes);
	for(i = 1; i < numNodes; i += 1)
	{
	//print("Util.RouteTo: Adding Route:", nodes[i-1], nodes[i]);
		this.AddGoalRoute(goalname, nodes[i-1], nodes[i]);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GoalRoutes = function(goalname, startname, goalroutes)
{
	foreach ( childname and child in goalroutes )
	{
		if(childname != "Weight")
		{
		//print("this.GoalRoutes: Goal Route:", goalname, startname, childname);
			this.AddGoalRoute(goalname, startname, childname, child.Weight);
			this.GoalRoutes(goalname, childname, child);
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member Routes = function(routetable)
{
// Loop through all the top level nodes, these are the goal names.
	foreach ( goalname and goalroutes in routetable )
	{
		Goals = Util.GoalTable(goalname);
		if (tableCount(Goals))
		{
			foreach ( name and route in goalroutes )
			{
				this.GoalRoutes(Goals, name, route);
			}
		}
		else
		{
			Util.MapDebugPrint("Util.Routes: Goal " + goalname + " not found!", true);
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member DistanceViewOn = true;

///////////////////////////////////////////////////////////////////////////////
//
member DistanceView = function(param)
{
	if ( param == "off" || param == "0" )
		{ this.DistanceViewOn = false; }
	else
		{ this.DistanceViewOn = true; }

	displaytime = 5;
	playerEnt = GetLocalEntity();
	playerId = GetGameIdFromEntity(playerEnt);

	while ( this.DistanceViewOn )
	{
		eyePos = GetLocalEyePosition();
		endPos = eyePos + GetLocalFacing() * 50000;
		tr = TraceLine( eyePos, endPos, 0, TRACE.SHOT, playerId, false );
		DrawDebugLine( eyePos, tr.end, COLOR.GREEN, displaytime );
		distance = DistanceBetween( eyePos, tr.end );
		s = format( "%f", distance  );
		output = "Distance:" + s;
		print( "Util.DistanceView:", output );
		EchoToScreen( displaytime, output );
		sleep( displaytime );
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member DefaultMovers =
{
	"MOVER_tank",
	"MOVER_truck",
	"MOVER_train1",
	"MOVER_train2",
	"MOVER_boat",
	"MOVER_train",
};

///////////////////////////////////////////////////////////////////////////////
//
member ProcessMoversCalled = false;
///////////////////////////////////////////////////////////////////////////////
//

member ResetMovers = function()
{
	this.ProcessMoversCalled = false;
	this.VehicleGoals = null; // clear old stuff
};

///////////////////////////////////////////////////////////////////////////////
//
member ProcessMovers = function()
{
	if ( this.ProcessMoversCalled )
		{ return; }

	this.ProcessMoversCalled = true;
	HaveTable = false;

	if ( Map && Map.ShowMovers )
		{ return; }

	this.VehiclesInMap();

	if ( Map && Map.Movers )
		{ HaveTable = true; }

	foreach ( vehEntity and Goal in this.VehicleGoals )
	{
		CurrentGoalName = Goal.GetName();
		deletegoal = true;

		foreach ( id and GoalName in this.DefaultMovers )
		{
			if ( !CurrentGoalName.Compare( GoalName ) )
			{
				deletegoal = false;
				break;
			}
		}

		if ( HaveTable && deletegoal )
		{
			foreach ( id and GoalName in Map.Movers )
			{
				if ( !CurrentGoalName.Compare( GoalName ) )
				{
					deletegoal = false;
					break;
				}
			}
		}

		if ( deletegoal )
		{
	//~ print("Util.ProcessMovers: Deleted:", CurrentGoalName);
			Goal.SetRemoveFlag(true);
		}
	}

	this.VehicleGoals = null;
	this.VehiclesInMap();

//~ GoalTable = table();
//~ GetGoals( GoalTable, 0, "MOVER.*" );

//~ foreach ( index and Goal in GoalTable )
//~ {
	//~ print("Util.ProcessMovers: GoalName:", Goal.GetName() );
//~ }
};

///////////////////////////////////////////////////////////////////////////////
//
member RemoveGoal = function( goalname )
{
	Goal = GetGoal( goalname );

	if ( !Goal )
		{ print("Util.RemoveGoal: goal:", goalname, "does not exist" ); }
	else
		{ Goal.SetRemoveFlag( true ); }
};

///////////////////////////////////////////////////////////////////////////////
//
member SetGoal = function( goalname, team )
{
	if ( typeId( goalname ) == 0 )
	{
		print( "Util.SetGoal: No goal name specified" );
		return;
	}

	if ( typeId( team ) == 0 )
	{
		team = 0;
	}
	SetAvailableMapGoals( team, true, goalname );
};

///////////////////////////////////////////////////////////////////////////////
//
member ClearGoal = function( goalname, team )
{
	if ( typeId( goalname ) == 0 )
	{
		print( "Util.ClearGoal: No goal name specified" );
		return;
	}

	if ( typeId( team ) == 0 )
	{
		team = 0;
	}
	SetAvailableMapGoals( team, false, goalname );
};

///////////////////////////////////////////////////////////////////////////////
//
member GetGoalEnt = function( goalname )
{
	Goal = GetGoal( goalname );

	if ( !Goal )
		{ print("Util.GetGoalEnt: goal:", goalname, "does not exist" ); }
	else
		{ return Goal.GetEntity(); }
};

///////////////////////////////////////////////////////////////////////////////
//
member AddWaypointArray = function( numx, distx, numy, disty )
{
	print("Util.AddWaypointArray: numx:", numx, "distx:", distx, "numy:", numy, "disty:", disty);
	playerPos = GetLocalPosition();

	for ( j = 0 ; j < numy ; j = j + 1 )
	{
		for ( i = 0 ; i < numx ; i = i + 1)
		{
			startPos = Vector3( playerPos.x + ( i * distx ),
				playerPos.y + ( j * disty ), playerPos.z );
		//~ print("Util.AddWaypointArray: startPos:", startPos);
			wpPos = this.FindGround( startPos );
		//~ print("Util.AddWaypointArray: wpPos:", wpPos);

			if ( wpPos )
				{ Wp.AddWaypoint( wpPos, Vector3( 0, 0, 0 ) ); }
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member FindGround = function( curPos )
{
	playerEnt = GetLocalEntity();
	playerId = GetGameIdFromEntity(playerEnt);
	playerPos = curPos;
	finalPos = null;
	testPos1 = Vector3( playerPos.x, playerPos.y,
		playerPos.z + Wp.BottomWaypointOffset);
	testPos2 = Vector3( playerPos.x, playerPos.y,
		playerPos.z + Wp.TopWaypointOffset);
	diff = testPos2 - testPos1;
	length = diff.Length();
	direction = diff.Normalize();
	tr = TraceLine( testPos1, testPos2, 0, TRACE.SHOT, playerId, false );

	if ( !tr.startsolid )
	{
	//~ print("Util.FindGround: Not in a solid");
	// segment is not in a solid, make sure its on the ground
		testPos3 = testPos1 - (direction * 100000);
		tr = TraceLine( testPos1, testPos3, 0, TRACE.SHOT, playerId,
			false );

		if ( tr.end )
		{
			testPos1 = tr.end;
			testPos2 = testPos1 + (direction * length);
			finalPos = Vector3( testPos1.x, testPos1.y,
				testPos1.z - Wp.BottomWaypointOffset);
		}

		return finalPos;
	}

//~ print("Util.FindGround: In a solid");
	attempts = 3125;

// segment start is in a solid, look for non solid start
	while ( tr.startsolid && attempts > 0 )
	{
		testPos1 += (direction * 32);
		testPos2 += (direction * 32);
		tr = TraceLine( testPos1, testPos2, 0, TRACE.SHOT, playerId,
			false );
		attempts -= 1;
	}

	if ( !tr.startsolid )
	{
		testPos3 = testPos1 - (direction * 32);
		tr = TraceLine( testPos1, testPos3, 0, TRACE.SHOT, playerId,
			false );
		testPos1 = tr.end;
		testPos2 = testPos1 + (direction * length);
		finalPos = Vector3( testPos1.x, testPos1.y,
			testPos1.z - Wp.BottomWaypointOffset);
	}

	return  finalPos;
};

///////////////////////////////////////////////////////////////////////////////
//
member TestMap = function( _params )
{
	if ( GetGameState() == "Playing" )
	{
		ExecScript( "testmap.gm" );
		TestMap.RunTests( _params );
	}
	else
	{
		print( "Util.TestMap: Can't run command during warmup" );
		EchoToScreen( 3, "Can't run command during warmup" );
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member AutoTestMap = function()
{
	params =
	{
	};

	if ( GetGameState() == "Playing" )
	{
		yield();
		this.TestMap( params );
		sleep( 2 );
		exit();
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member AddBotTester = function( team, class, name )
{
// Add Tester bot
	sleep( 1 );
	AddBot(team, class, name);
	sleep( 1 );

	while ( tableCount( BotTable ) == 0 )
		{ sleep( 0.5 ); }

	botPtr = this.GetBotPointer( name );
	Util.SetAllRoles(botPtr);
	return botPtr;
};

///////////////////////////////////////////////////////////////////////////////
//
member TestBot = function( _params )
{
	team = ToInt(_params[0], 0);
	class = ToInt(_params[1], 0);

	if ( _params[ 0 ] == 0 )
	{
		KickBot( "testbot" );
		global TestBot = false;
		return;
	}

	if ( Names["testbot"] == "" )
		{ Names["testbot"] = "testbot.gm"; }

	global TestBot = true;
	AddBot( team, class, "testbot");
};

///////////////////////////////////////////////////////////////////////////////
//
member WeaponName = function(weaponId)
{
	if (!weaponId)
	{
		return "NONE";
	}
	if (weaponId == WEAPON.MORTAR)
	{
		return "MORTAR"; //same as GRANATWERFER
	}
	if (weaponId == WEAPON.MOBILE_MG42)
	{
		return "MOBILE_MG42"; //same as MOBILE_BROWNING
	}
	foreach ( name and Id in WEAPON )
	{
		if(weaponId == Id)
		{
			return name;
		}
	}
	return "UnknownWeapon" + weaponId;
};

member WeaponNameToId = function(weap)
{
	foreach( name and Id in WEAPON )
	{
		if ( !weap.CompareNoCase(name) )
		{
			return Id;
		}
	}

	return -1;
};

///////////////////////////////////////////////////////////////////////////////
//
member ButtonName = function(buttonId)
{
	foreach ( name and Id in BTN )
	{
		if(buttonId == Id)
		{
			return name;
		}
	}
	return "UnknownButton";
};

member ButtonNameToId = function(button)
{
	foreach( name and Id in BTN )
	{
		if ( !button.CompareNoCase(name) )
		{
			return Id;
		}
	}

	return -1;
};

///////////////////////////////////////////////////////////////////////////////
//
member TeamName = function(teamId)
{
	foreach ( name and Id in TEAM )
	{
		if(teamId == Id)
		{
			return name;
		}
	}
	return "UnknownTeam";
};

///////////////////////////////////////////////////////////////////////////////
//
member TeamNameToId = function(name)
{
	foreach( name and Id in TEAM )
	{
		if ( !name.CompareNoCase(name) )
		{
			return Id;
		}
	}

	return -1;
};

///////////////////////////////////////////////////////////////////////////////
//
member ClassName = function(classId)
{
	foreach ( name and Id in CLASS )
	{
		if(classId == Id)
		{
			return name;
		}
	}
	return "UnknownClass for id "+ classId;
};

///////////////////////////////////////////////////////////////////////////////
//
member CatName = function(catId)
{
	foreach ( name and Id in CAT )
	{
		if(catId == Id)
		{
			return name;
		}
	}
	return "UnknownCategory for id "+ catId;
};

///////////////////////////////////////////////////////////////////////////////
// cache goal positions indexed by goal name
member CacheGoalPositions = function(forceUpdate)
{
	if (!Util.GoalPositionsTable || forceUpdate)
	{
		Util.GoalPositionsTable = table();
		if ( tableCount(Util.GoalPositionsTable) < 1 ) {
			goals = Util.GoalTable(".*");
			foreach ( id and goal in goals ) {
				Util.GoalPositionsTable[ goal.GetName() ] = goal.GetPosition();
			}
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
// echo to screen the closest goal that is being rendered within a given range.
member EchoCloseGoal = function(range, extraText)
{
	Util.CacheGoalPositions(true);
	playerPos = GetLocalPosition();
	closestGoal = null;
	closestDistance = 9999;
	if ( !range ) { range = 10000; }
	if ( !extraText ) { extraText = ""; }

	foreach( goalName and goalPos in Util.GoalPositionsTable )
	{
		dist = DistanceBetween(playerPos, goalPos);
		if ( GetGoal(goalName).RenderGoal == 1 && dist < range && dist < closestDistance ) {
			closestGoal = goalName;
			closestDistance = dist;
		}
	}

	if ( closestGoal ) {
		s = format("^2%s %s", closestGoal, ToString(extraText));
	}
	else {
		s = "^1No Enabled or Rendered Goals in range, check console";
	}

	EchoToScreen(10, s);
};

///////////////////////////////////////////////////////////////////////////////
//
member ShowGoalName = function (radius, showOffset)
{
	if ( !radius ) { radius = 100; }
	playerPos = GetEntPosition(GetLocalEntity());
	foundGoal = false;

	GoalTable = table();
	GetGoals(GoalTable, 0, ".*");

	foreach ( id and mapgoal in GoalTable )
	{
		if ( this.Distance(mapgoal.GetPosition(), playerPos) < radius )
		{
			foundGoal = true;
			ent = mapgoal.GetEntity();
			if(ent)
			{
				DrawEntityAABB( ent, 20, COLOR.BLUE );
			}
			gName = mapgoal.GetName();
			print("Util.ShowGoalName: Found: ", gName);
			if (showOffset && ent)
				{ this.ShowGoalOffset(gName); }
		}
	}

	if ( !foundGoal )
		{ print("Util.ShowGoalName: No goal found"); }
};

///////////////////////////////////////////////////////////////////////////////
//
member ShowGoalOffset = function (goalname)
{
	g = GetGoal(goalname);
	if ( !g )
	{
		print("Util.ShowGoalOffset: ERROR: Invalid goalname");
		return;
	}

	pPos = GetLocalPosition();
	offset = GetEntityLocalSpace(g.GetEntity(), pPos);

	print("Util.ShowGoalOffset: Offset:", offset);
};

///////////////////////////////////////////////////////////////////////////////
//
member ShowGoalInfo = function ( goalname )
{
	goal = GetGoal( goalname );

	if ( !goal )
	{
		print("Util.ShowGoalInfo: ERROR: Invalid goalname");
		return;
	}

	entity = goal.GetEntity();
	goalha = {};
	GetEntHealthAndArmor( entity, goalha );
	dead = false;

	if ( GetEntFlags( entity, ENTFLAG.DEAD ) )
		{ dead = true; }

	goalPos = goal.GetPosition();

	print(   "Util.ShowGoalInfo:", "goalname:", goalname, "goal:", goal );
	print(   "Util.ShowGoalInfo:", "entity:", entity, "health:", goalha.Health,
		"dead:", dead );
	print(   "Util.ShowGoalInfo:", "goalPos:", goalPos );
};

///////////////////////////////////////////////////////////////////////////////
//Disable a goal for all teams
member DisableGoal = function( goal, routes )
{
	SetAvailableMapGoals( 0, false, goal );

	if (routes)
	{
		SetAvailableMapGoals( 0, true, "ROUTE_.*" );
	}
};

///////////////////////////////////////////////////////////////////////////////
//Enable a goal for all teams
member EnableGoal = function( goal )
{
	SetAvailableMapGoals( 0, true, goal );
};

///////////////////////////////////////////////////////////////////////////////
//Limit a goal to one team
member LimitGoal = function( team, goal )
{
	SetAvailableMapGoals( 0, false, goal );
	SetAvailableMapGoals( team, true, goal );
};

member LimitToTeam = function( team, goal )
{
	SetAvailableMapGoals( 0, false, goal );
	SetAvailableMapGoals( team, true, goal );
};

///////////////////////////////////////////////////////////////////////////////
//
member GetGroup = function(exp)
{
	goals = table();

	if ( typeId(exp) == 0 )
	{
		print("Util.GetGroup: Invalid Group expression");
		return goals;
	}

	params = { Group=exp, SkipInUse=false, SkipNoInuse=false, SkipNoInProgress=false, };
	GetGoals(goals, 0, ".*", params);
	return goals;
};

///////////////////////////////////////////////////////////////////////////////
//
member SetGroup = function(goalExp, group)
{
	gt = Util.GoalTable(goalExp);

	if ( tableCount(gt) > 0 )
	{
		foreach ( id and goal in gt )
		{
			goal.SetGroupName(group);
		}
	}
	else
	{
		print("Util.SetGroup: Invalid Goal Expression ", goalExp);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetGroupForTable = function(tbl, group)
{
	foreach ( id and exp in tbl )
	{
		type = typeId(exp);

		if ( type == 6 ) // table
		{
			this.SetGroupForTable(exp, group);
		}
		else if ( type == 5 )  // string
		{
			this.SetGroup(exp, group);
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member EnableGroup = function(group, team)
{
	groupTable = this.GetGroup(group);

	foreach ( id and goal in groupTable )
	{
		if ( team )
			{ goal.SetAvailable( team, true); }
		else
		{
			goal.SetAvailable( 1, true );
			goal.SetAvailable( 2, true );
			goal.SetAvailable( 3, true );
			goal.SetAvailable( 4, true );
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member DisableGroup = function(group, team)
{
	groupTable = this.GetGroup(group);

	foreach ( id and goal in groupTable )
	{
		if ( team )
			{ goal.SetAvailable( team, false); }
		else
		{
			goal.SetAvailable( 1, false );
			goal.SetAvailable( 2, false );
			goal.SetAvailable( 3, false );
			goal.SetAvailable( 4, false );
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ShowGroup = function(group)
{
	groupTable = this.GetGroup(group);

	print("----- Group:",group,"-----");
	foreach ( id and goal in groupTable )
	{
		print(goal.GetName());
	}
	print("----- End Group -----");
};

///////////////////////////////////////////////////////////////////////////////
//
member SetRoleForGoals = function(exp, role)
{
	gt = Util.GoalTable(exp);
	isRoleTable = typeName(role) == "table";

	foreach ( id and goal in gt )
	{
		if ( isRoleTable ) {
			foreach ( id in role ) {
				goal.SetRoles(id);
			}
		}
		else {
			goal.SetRoles(role);
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ClearRoleForGoals = function(exp, role)
{
	gt = Util.GoalTable(exp);
	isRoleTable = typeName(role) == "table";

	foreach ( id and goal in gt )
	{
		if ( isRoleTable ) {
			foreach ( id in role ) {
				goal.ClearRoles(id);
			}
		}
		else {
			goal.ClearRoles(role);
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetRoleForTable = function(tbl, role)
{
	foreach ( id and exp in tbl )
	{
		this.SetRoleForGoals(exp, role);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ClearRoleForTable = function(tbl, role)
{
	foreach ( id and exp in tbl )
	{
		this.ClearRoleForGoals(exp, role);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetRoleForGroup = function(group, role)
{
	groupTable = this.GetGroup(group);
	isRoleTable = typeName(role) == "table";

	foreach ( id and goal in groupTable )
	{
		if ( isRoleTable ) {
			foreach ( id in role ) {
				goal.SetRoles(id);
			}
		}
		else {
			goal.SetRoles(role);
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ClearRoleForGroup = function(group, role)
{
	groupTable = this.GetGroup(group);
	isRoleTable = typeName(role) == "table";

	foreach ( id and goal in groupTable )
	{
		if ( isRoleTable ) {
			foreach ( id in role ) {
				goal.ClearRoles(id);
			}
		}
		else {
			goal.ClearRoles(role);
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ExecOnBots = function( param )
{
	if ( param )
	{
		foreach ( id and bot in BotTable )
		{
			bot.ExecCommand(param);
		}
	}
	else
		{ print("Util.ExecOnBots: Invalid or no Param"); }
};

///////////////////////////////////////////////////////////////////////////////
//
member KillGoal = function( Goals )
{
	GoalTable = table();
	GetGoals( GoalTable, 0, Goals );

	foreach ( index2 and goal in GoalTable )
	{
		if ( goal.GetEntity() )
			{ EntityKill( goal.GetEntity() ); }
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ClearWaypointNames = function(verbose)
{
	if ( !Wp.IsWaypointViewOn() )
	{
		print( "ERROR: Waypoint View must be enabled" );
		return;
	}

	wpTable = {};
	Wp.GetAllWaypoints(wpTable);

	foreach ( id and waypoint in wpTable )
	{
		Wp.SetWaypointName( id, "" );
		if(verbose == "true" )
			{ print("cleared wp name from wp id: ", id); }
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member IgnorePlayer = function(param)
{
	if ( param == "on" || param == "1" )
	{
		print("Ignore is On");
		time = 9999;
	}
	else
	{
		print("Ignore is Off");
		time = 0.1;
	}

	foreach ( id and bot in BotTable )
	{
		bot.IgnoreTarget(GetLocalEntity(), time);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member IgnoreTargetGoal = function( bot, goalname, time )
{
	if ( !time ) { time = 9999; }
	g = GetGoal(goalname);

	if( g )
	{
		bot.IgnoreTarget( g.GetEntity(), time );
	}
	else
	{
		Util.MapDebugPrint("Util.IgnoreTargetGoal: Invalid Goalname: " + goalname, true);
		return false;
	}

	return true;
};

///////////////////////////////////////////////////////////////////////////////
//
member IgnoreTargetGoalAllBots = function(goalname)
{

	foreach (id and bot in BotTable) {
		if ( Util.IgnoreTargetGoal(bot, goalname) == false ) {
			break;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member IgnoreTargetGoalTable = function( bot, goaltable )
{
	foreach ( i and goalname in goaltable )
		{ this.IgnoreTargetGoal( bot, goalname ); }
};

///////////////////////////////////////////////////////////////////////////////
//
member IgnoreTargetGoalAll = function( goalname )
{
	goal = GetGoal(goalname);

	if( goal )
		{ foreach ( i and bot in BotTable )
			{ bot.IgnoreTarget( goal.GetEntity(), 9999 );  } }
	else
		{ print("Util.IgnoreTargetGoalAll: Invalid Goalname: ", goalname); }
};

///////////////////////////////////////////////////////////////////////////////
//
member IgnoreTargetGoalTableAll = function( goaltable )
{
	foreach ( i and goalname in goaltable )
		{ this.IgnoreTargetGoalAll( goalname ); }
};

///////////////////////////////////////////////////////////////////////////////
//
member AddInvVehicle = function ( goalname )
{
	if ( !Map )
		{ global Map = table(); }

	if ( !Map.InvVehicle )
		{ Map.InvVehicle = table(); }

	g = GetGoal(goalname);
	Map.InvVehicle[ g.GetEntity() ] = true;
};

///////////////////////////////////////////////////////////////////////////////
//
member TestVoiceMacro = function(macroname)
{
	if ( !macroname )
	{
		print ( "ERROR: Util.TestVoiceMacro: expecting macro name" );
		return;
	}

	tester = null;

	foreach ( id and bot in BotTable )
	{
		tester = bot;
		break;
	}

	if ( !tester )
	{
		print( "ERROR: Util.TestVoiceMacro: No Bot found" );
		return;
	}

	vmID = VOICE[macroname];

	if ( !vmID )
	{
		print( "ERROR: Util.TestVoiceMacro: Voice Macro ID not found" );
		return;
	}

	tester.SayVoice(vmID);
};

///////////////////////////////////////////////////////////////////////////////
//
member TestGoalPriorities = function(allgoals)
{
	mgt = {};
	GetGoals(mgt, 0, ".*" );

	foreach ( id and mg in  mgt )
	{
		mg.SetGoalPriority( 1, 1, 1.0 );
		assert( mg.GetGoalPriority(1, 1) == 1.0 );
		print( "TestPriorities: Test 1 Pass" );
		yield();

		mg.SetGoalPriority( 2, 1, 0.9 );
		assert( mg.GetGoalPriority(1, 1) == 1.0 );
		assert( mg.GetGoalPriority(2, 1) == 0.9 );
		print( "TestPriorities: Test 2 Pass" );
		yield();

		mg.SetGoalPriority( 1, 1, 0.8 );
		mg.SetGoalPriority( 1, 2, 0.8 );
		assert( mg.GetGoalPriority(1, 1) == 0.8 );
		assert( mg.GetGoalPriority(1, 2) == 0.8 );
		assert( mg.GetGoalPriority(2, 1) == 0.9 );
		print( "TestPriorities: Test 3 Pass" );
		yield();

		mg.SetGoalPriority( 2, 2, 0.7 );
		assert( mg.GetGoalPriority(1, 1) == 0.8 );
		assert( mg.GetGoalPriority(1, 2) == 0.8 );
		assert( mg.GetGoalPriority(2, 1) == 0.9 );
		assert( mg.GetGoalPriority(2, 2) == 0.7 );
		print( "TestPriorities: Test 4 Pass" );
		yield();

		mg.SetGoalPriority( 0, 0, 0.6 );
		assert( mg.GetGoalPriority(1, 1) == 0.6 );
		assert( mg.GetGoalPriority(1, 2) == 0.6 );
		assert( mg.GetGoalPriority(2, 1) == 0.6 );
		assert( mg.GetGoalPriority(2, 2) == 0.6 );
		print( "TestPriorities: Test 5 Pass" );
		yield();

		mg.SetGoalPriority( 1, 1, 0.0 );
		assert( mg.GetGoalPriority(1, 1) == 0.0 );
		assert( mg.GetGoalPriority(1, 2) == 0.6 );
		assert( mg.GetGoalPriority(2, 1) == 0.6 );
		assert( mg.GetGoalPriority(2, 2) == 0.6 );
		print( "TestPriorities: Test 6 Pass" );
		yield();

		mg.SetGoalPriority( 1, 2, 0.5 );
		mg.SetGoalPriority( 2, 1, 0.4 );
		mg.SetGoalPriority( 2, 2, 0.3 );
		assert( mg.GetGoalPriority(1, 1) == 0.0 );
		assert( mg.GetGoalPriority(1, 2) == 0.5 );
		assert( mg.GetGoalPriority(2, 1) == 0.4 );
		assert( mg.GetGoalPriority(2, 2) == 0.3 );
		print( "TestPriorities: Test 7 Pass" );
		yield();

		print( "--------------------" );
		print( "TestPriorities: All tests passed" );
		print( "--------------------" );
		yield();

		ExecCommand( "show_goals " + mg.GetName() + " p" );

		if ( !allgoals )
			{ break; }
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GoalTable = function(expr, team)
{
	if ( typeId(team) == 0 )
	{
		team = 0;
	}

	if (!expr) { expr = ".*"; }

	gt = {};
	GetGoals( gt, team, expr );
	return gt;
};

///////////////////////////////////////////////////////////////////////////////
//
member GoalExists = function(goalname)
{
	if(GetGoal(goalname))
	{
		return true;
	}

	return false;
};

///////////////////////////////////////////////////////////////////////////////
//
member MapDebugPrint = function(message, msgonly)
{
	if ( !Map )
	{
		global Map = table();
	}

	if ( DEBUG_MAP_SCRIPTS || Map.Debug == true )
	{
		if ( !msgonly && (DEBUG_GOAL_AVAILABILITY || Map.DebugAvailability) )
		{
			yield(); yield();
			this.ShowActiveGoals();
		}
		print(format("%s%s", Util.DebugColorString, message));
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ScriptDebugPrint = function(goalName, dbgType, msg)
{
	if (!DEBUG_SCRIPT_GOALS && (!Map || !Map.Debug) || !DEBUG_SCRIPT_GOALS_FILTER[dbgType]) { return; }

	if (!msg)
	{
		switch(dbgType)
		{
			case "pathfailed":
			{
				msg = "path failed, check reachability";
			}
			case "timedout":
			{
				msg = "failed, timeout";
			}
			case "disabled":
			{
				msg = "disabled, invalid goal setup";
			}
			default:
			{
				msg = "";
			}
		}
	}
	print(format("%s%s: %s %s", Util.DebugColorString, dbgType, goalName, msg));
};

///////////////////////////////////////////////////////////////////////////////
//
member MapDeprecateMessage = function(oldfunc, newfunc)
{
	this.MapDebugPrint( oldfunc + " is deprecated. use " + newfunc, true );
};

///////////////////////////////////////////////////////////////////////////////
//
member RandomSpawn = function( team, spawn )
{
	if ( Util.RandomSpawnThreadId == null ) {
		Util.RandomSpawnThreadId = thread(Util.RandomSpawnThread, team, spawn);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member RandomSpawnThread = function( team, spawn )
{
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team )
		{
			if ( RandInt( 0, 1 ) < 1 )
			{
				bot.ChangeSpawnPoint( spawn );
			}
		}

		sleep(1);
	}

	Util.RandomSpawnThreadId = null;
};

///////////////////////////////////////////////////////////////////////////////
//
member ChangeSpawn = function( team, spawn, numbots, class )
{
	c = 0;
	b = 0;

	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team )
		{
			b += 1;

			// every other bot to avoid low bot count numbers spawning all at a point
			if ( numbots && numbots != -1 && (b % 2 == 0) ) {
				continue;
			}

			// is it class limited?
			if ( class && bot.GetClass() != class ) {
				continue;
			}

			c += 1;
			bot.ChangeSpawnPoint( spawn );

			if ( numbots && c >= numbots )
				{ return; }
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ChangeSpawnForRole = function( team, role, spawn )
{
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team && bot.HasRole(role) )
		{
			bot.ChangeSpawnPoint( spawn );
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ChangeBotSpawn = function( bot, team, spawn, numbots )
{
	if ( bot.GetTeam() != team ) { return; }

	if ( !Server.Team[team].NumChangedSpawn )
	{
		Server.Team[team].NumChangedSpawn = 0;
	}


	if ( Server.Team[team].Numbots % 2 == 0 && Server.Team[team].NumChangedSpawn < numbots )
	{
		Server.Team[team].NumChangedSpawn += 1;
		bot.ChangeSpawnPoint(spawn);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member RandomBotSpawn = function( bot, team, spawn )
{
	if ( bot.GetTeam() == team )
	{
		if ( RandInt( 0, 9 ) < 5 )
		{
			bot.ChangeSpawnPoint( spawn );
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetRandomFromTable = function(tbl)
{
		randomIndex = -1;

		if ( typeId(tbl) == 6 )
		{
			count = tableCount(tbl);
			randomIndex = RandInt(0, count-1);
		}

		return randomIndex;
};

///////////////////////////////////////////////////////////////////////////////
//
member OneBotSay = function(msg)
{
	Util.MapDeprecateMessage( "Util.OneBotSay", "Util.BotChat" );
	foreach (id and bot in BotTable)
	{
		bot.Say(msg);
		return;
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member BotSay = function(bot, msg)
{
	if ( MAP_TALK ) {
		bot.Say(msg);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member OneBotSayTeam = function(team, msg)
{
	Util.MapDeprecateMessage( "Util.OneBotSayTeam", "Util.BotChat" );
	foreach (id and bot in BotTable)
	{
		if ( bot.GetTeam() == team )
		{
			bot.SayTeam(msg);
			return;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member OneBotVSayTeam = function(team, vchat)
{
	Util.MapDeprecateMessage( "Util.OneBotVSayTeam", "Util.BotChat" );
	foreach (id and bot in BotTable)
	{
		if ( bot.GetTeam() == team )
		{
			bot.SayVoice(vchat);
			return;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
// types - "say", "sayteam", "vsay"
// team 0 = all teams
member BotChat = function(team, msgType, msg, numBots)
{
	if ( MAP_TALK )
	{
		bots = 0;
		foreach ( id and bot in BotTable )
		{
			if ( numBots && bots >= numBots ) {
				return;
			}
			if ( team != 0 && bot.GetTeam() != team ) {
				continue;
			}

			switch(msgType)
			{
				case "say":
				{
					if ( typeName(msg) != "string" ) {
						Util.MapDebugPrint("Util.BotChat: expecting string for say", true);
						return;
					}

					bot.Say(msg);
				}
				case "sayteam":
				{
					if ( typeName(msg) != "string" ) {
						Util.MapDebugPrint("Util.BotChat: expecting string for sayteam", true);
						return;
					}

					bot.SayTeam(msg);
				}
				case "vsay":
				{
					if ( typeName(msg) != "int" ) {
						Util.MapDebugPrint("Util.BotChat: expecting voiceid for vsay", true);
						return;
					}

					bot.SayVoice(msg);
				}
				default:
				{
					Util.MapDebugPrint("Util.BotChat: Invalid message type!", true);
				}
			}

			bots += 1;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ShowActiveGoals = function(render, routes, showuse)
{
	GoalTable = table();
	if (render)
	{
		ExecCommand("draw_goals off");
	}

	foreach ( name and teamId in TEAM )
	{
		teamName = Util.TeamName(teamId);

		if ( teamName == "SPECTATOR" ) { continue; }

		GetGoals( GoalTable, teamId, ".*" );

		print("--------------" + teamName + "--------------");

		foreach( goalId and goal in GoalTable )
		{
			goalName = goal.GetName();

			if (!routes && (goalName.Find("ROUTE") != -1) ) { continue; }

			if ( !showuse && ((typeId(render) != 0 && render == 0) || render == teamId) )
			{
				goal.RenderGoal = true;
			}

			if ( !showuse ) {
				print( teamName + ": " + goalName + " is active" );
			}
			else {
				print(format("%s: %s is active | inUse: %d - inProgress: %d",
					teamName, goalName, goal.MaxUsers_InUse(), goal.MaxUsers_InProgress()));
			}
		}

		// script based switch goals
		if ( Map && Map.Switches ) {
			teamMask = (1<<teamId);
			foreach ( id and switchTable in Map.Switches ) {
				if ( switchTable.Enabled && (typeId(switchTable.LimitTeam) == 0 || (switchTable.LimitTeam & teamMask)) ) {
					print(format("%s: Scripted Switch %s is active", teamName, switchTable.WaypointName));
				}
			}
		}

		tableClear(GoalTable);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member TeamClassCounter = function()
{
	this.ResetClassCounters();

	// count humans too
	for ( i = 0; i <= Server.NumPlayers; i = i + 1 )
	{
		if ( !EntityIsValid(i) )
		{
			continue;
		}

		team = GetEntTeam(i);

		if (team && Util.TeamName(team) != "SPECTATOR")
		{
			class = GetEntClass(i);
			if (class)
			{
				if (Server.ClassCount[team][class] < 1)
				{
					Server.ClassCount[team][class] = 1;
				}
				else
				{
					Server.ClassCount[team][class] += 1;
				}
			}
		}

		yield(); // split it up over frames
	}
};

member InitializeClassTables = function()
{
	foreach ( name and teamId in TEAM )
	{
		if ( name == "SPECTATOR" )
		{
			continue;
		}

		Server.ClassCount[teamId] = table();
		Server.MinClassCount[teamId] = table();

		foreach (classId in Util.PlayerClassTable)
		{
			Server.ClassCount[teamId][classId] = 0;
		}
	}

	this.ClassTablesInitialized = true;
};

///////////////////////////////////////////////////////////////////////////////
//
member IsSnipeMap = false;
member SnipeMap = function()
{
	if (!Util.SniperClass)
	{
		print("Util.SnipeMap: No Util.SniperClass defined");
		return;
	}

	this.IsSnipeMap = true;

	// reset the min class counts
	this.InitializeClassTables();

	foreach ( name and teamId in TEAM )
	{
		if ( name == "SPECTATOR" )
		{
			continue;
		}

		Server.MinClassCount[teamId][Util.SniperClass] = Server.MaxPlayers;
	}

	foreach ( id and bot in BotTable )
	{
		this.ChangeToSniperWeapons(bot); //also add to OnBotJoin
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ChangeToSniperWeapons = function(bot, viewDistance)
{
	yield(); yield();
	teamName = this.TeamName(bot.GetTeam());

	if ( !viewDistance ) { viewDistance = 10000; }

	if ( Util.TeamSniperWeapons[teamName] )
	{
		if ( !bot.CanSnipe() )
		{
			if ( bot.GetClass() != Util.SniperClass ) {
				bot.ChangeClass(Util.SniperClass);
				yield();
			}
			n = tableCount(Util.TeamSniperWeapons[teamName]);
			r = RandInt(0, n-1);
			bot.ChangePrimaryWeapon(Util.TeamSniperWeapons[teamName][r]);
		}
		bot.MaxViewDistance = viewDistance;
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetTableKey = function(tbl, value)
{
	foreach ( k and v in tbl )
	{
		if ( value == v )
		{
			return k;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member GetTableValue = function(tbl, key)
{
	foreach ( k and v in tbl )
	{
		if ( key == k )
		{
			return v;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ListTableMembers = function(tbl, sortBy)
{
	if ( IsTable(tbl) ) {
		noParam = !sortBy || sortBy=="null";
		if(noParam){ sortBy = "key"; }
		sortedTable = tableSort(tbl, sortBy);
		foreach(value in sortedTable) {
			if(noParam) {
				print("  " + value + "  " + ToString(tbl[value]));
			} else {
				print("     "+value);
			}
		}
	}
	else {
		print("Util.ListTableMembers: Expected table, got " + typeName(tbl));
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member AmmoForWeapon = function(bot,wpn)
{
	ammoTable = table();
	bot.GetCurrentAmmo(ammoTable, 0, wpn);

	return ammoTable.CurrentAmmo;
};

///////////////////////////////////////////////////////////////////////////////
//
member HasAmmoForWeapon = function(bot,wpn)
{
	if ( Util.AmmoForWeapon(bot, wpn) > 0 ) {
		return true;
	}

	return false;
};

///////////////////////////////////////////////////////////////////////////////
//
member BotHasAnyRole = function(bot)
{
	foreach ( id and role in ROLE ) {
		if(bot.HasRole(role)) {
			return true;
		}
	}

	return false;
};

///////////////////////////////////////////////////////////////////////////////
//
member SystemUsageTimeline = function(interval)
{
	if ( !interval ) { interval = 1; }
	lastFullCollect = 0;
	lastIncCollect = 0;

	gmfile = File();
	fileName = "systemtimeline.gm";

	while(1)
	{
		if ( !System.FileExists(fileName) ) {
			assert( gmfile.Open( fileName, "text", false ) );
		}
		else {
			assert( gmfile.Open( fileName, "text", false, true ) );
		}

		currentFullCollect = sysGetStatsGCNumFullCollects();
		fullCollectsForInterval = currentFullCollect - lastFullCollect;
		lastFullCollect = currentFullCollect;
		currentIncCollect = sysGetStatsGCNumIncCollects();
		incCollectsForInterval = currentIncCollect - lastIncCollect;
		lastIncCollect = currentIncCollect;
		assert( gmfile.Write(
			"time: ", sysTime(),
			" | currentmem: ", sysGetMemoryUsage(),
			" | fullcollects: ", fullCollectsForInterval,
			" | inccollects: ", incCollectsForInterval,
			System.NewLine ) );
		gmfile.Close();
		sleep(interval);
	}

	print("finished system usage timeline");
};

///////////////////////////////////////////////////////////////////////////////
//
member GetEntHealth = function(ent)
{
	haTable = {};
	GetEntHealthAndArmor(ent, haTable);
	return haTable.Health;
};

///////////////////////////////////////////////////////////////////////////////
// "day", "date", "time", "m"
member TimeFormat = function(param)
{
	time = System.Time();
	tokenized = time.Tokenize(" ");

	switch(param)
	{
		case "day":
		{
			return tokenized[0];
		}
		case "date":
		{
			year = tokenized[3].SpanExcluding(",");
			s = format("%s %s %s", tokenized[1], tokenized[2], year);
			return s;
		}
		case "time":
		{
			s = format("%s %s", tokenized[4], tokenized[5]);
			return s;
		}
		case "m": // meridiem
		{
			return tokenized[5];
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetAllRoles = function(obj)
{
	type = typeName(obj);
	if ( type == "MapGoal" || type == "Bot" ) {
		// well this is lame
		obj.SetRoles(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);
	}
	else {
		print("Util.SetAllRoles: expected MapGoal or Bot, got " + type );
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member FindPaththroughNodes = function()
{
	if (!Map) { global Map = table(); }
	if (!Map.PTNodes) { Map.PTNodes = table(); }

	// repeated calls refresh the list
	tableClear(Map.PTNodes);

	wpTable = {};
	Wp.GetAllWaypoints( wpTable );

	foreach( id and waypoint in wpTable ) {
		foreach( ptype and value in waypoint.property ) {
			if ( ptype == "paththrough" ) {
				Map.PTNodes[ id ] = table();
				Map.PTNodes[ id ].position = waypoint.position;
				Map.PTNodes[ id ].name = value;
			}
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member RenderPaththroughNodes = function(param)
{
	if ( param == 1 ) {
		Util.FindPaththroughNodes();
		if ( Map.PTNodes ) {
			num = tableCount(Map.PTNodes);
			if ( num > 0 ) {
				print(format("rendering %d paththrough nodes", num));
				Map.RenderPT = true;
			}
		}
	}
	else {
		Map.RenderPT = false;
	}

	while( Map.RenderPT ) {
		foreach ( id and ptnode in Map.PTNodes ) {
			DrawText3d(ptnode.position+Vector3(0,0,48),ptnode.name,COLOR.YELLOW,2,1000);
		}
		sleep(2);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ForceRouting = function(goalname, set)
{
	mg = GetGoal(goalname);
	if (mg) {
		mg.ForceRouting = set;
	}
	else {
		Util.MapDebugPrint("Util.ForceRouting: Invalid goal name " + goalname, true);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetCustomProperty = function(goalname, property, value)
{
	mg = GetGoal(goalname);
	if (mg) {
		mg.SetProperty(property, value);
	}
	else {
		Util.MapDebugPrint("Util.SetCustomProperty: Invalid goal name " + goalname, true);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetGoalRange = function(goalname, range)
{
	mg = GetGoal(goalname);
	if (mg) {
		mg.SetRange(range);
	}
	else {
		Util.MapDebugPrint("Util.SetGoalRange: Invalid goal name " + goalname, true);
	}
};

///////////////////////////////////////////////////////////////////////////////
// Finds goal closest to local player inside a given radius.
// All arguments are optional.
member FindClosestGoal = function( radius, regEx, team )
{
	if ( !radius )
		{ radius = 200; }
	if ( !regEx )
		{ regEx = ".*"; }
	if ( !team )
		{ team = 0; }
	dist = null;
	playerPos = GetLocalPosition();
	foundGoal = null;
	mapgoals = table();

	GetGoals( mapgoals, team, regEx );
	foreach ( id and mapgoal in mapgoals )
	{
		evalDist = Util.Distance( mapgoal.GetPosition(), playerPos );
		if ( evalDist < radius )
		{
			if ( !dist || evalDist < dist )
			{
				dist = evalDist;
				foundGoal = mapgoal;
			}
		}
	}

	return foundGoal;
};

///////////////////////////////////////////////////////////////////////////////
//
member GetRandomTableValue = function(tbl)
{
		if ( typeId(tbl) == 6 )
		{
			count = tableCount(tbl);
			if (count > 0)
			{
				return tbl[RandInt(0, count-1)];
			}
		}

		return null;
};

